<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-12-04 Wed 13:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hopf Fibrations</title>
<meta name="author" content="Shrisha Rao" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Hopf Fibrations</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org08eb99b">1. Exploring Hopf Fibrations</a>
<ul>
<li><a href="#orgfa1874b">1.1. Base Space</a></li>
<li><a href="#org6b65ea9">1.2. Fibers</a></li>
<li><a href="#orgeb8a3fc">1.3. Total Space</a></li>
<li><a href="#org3b525ac">1.4. What is a Hopf Fibration?</a></li>
<li><a href="#orgee581e6">1.5. Why Does It Matter in Physics?</a></li>
</ul>
</li>
</ul>
</div>
</div>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
<link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

<div id="outline-container-org08eb99b" class="outline-2">
<h2 id="org08eb99b"><span class="section-number-2">1.</span> Exploring Hopf Fibrations</h2>
<div class="outline-text-2" id="text-1">
<p>
The Hopf fibration is an interesting concept providing insights into geometry,<br />
topology, and QM. We will explore what Hopf fibrations are and their<br />
significance in physics.<br />
</p>

<p>
In geometry, the concepts of <code>base space</code>, <code>fibers</code>, and <code>total space</code> are<br />
fundamental for understanding structures like fiber bundles and fibrations.<br />
</p>
</div>

<div id="outline-container-orgfa1874b" class="outline-3">
<h3 id="orgfa1874b"><span class="section-number-3">1.1.</span> Base Space</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The <code>base space</code> is the "foundation" over which everything is organized. It is<br />
typically a lower-dimensional space that provides the framework for the<br />
structure of the fiber bundle.<br />
</p>

<ul class="org-ul">
<li><b>Example</b>: In case of a cylinder, the base space is the disc.<br />
\( D=\{(x, y)\in {\mathbb R^2}: (x-a)^2+(y-b)^2 \le R^2\} \)<br /></li>
</ul>
</div>
</div>

<div id="outline-container-org6b65ea9" class="outline-3">
<h3 id="org6b65ea9"><span class="section-number-3">1.2.</span> Fibers</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Fibers are the individual "threads" or spaces that are attached to each point of<br />
the base space. They are often all the same type of space, forming a consistent<br />
"shape" across the entire structure.<br />
</p>

<ul class="org-ul">
<li><b>Example</b>: In case of a cylinder, the fibers are circles, straight lines, attached to each point on the disc.<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgeb8a3fc" class="outline-3">
<h3 id="orgeb8a3fc"><span class="section-number-3">1.3.</span> Total Space</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The <code>total space</code> is the "combined" space that includes both the base space and<br />
all the fibers. It can be thought of as the entire structure before projecting<br />
down to just the base space.<br />
</p>

<ul class="org-ul">
<li><b>Example</b>: In case of a cylinder, the total space is the cylinder in \( \mathbb
  {R}^3 \)<br /></li>
</ul>
</div>
</div>


<div id="outline-container-org3b525ac" class="outline-3">
<h3 id="org3b525ac"><span class="section-number-3">1.4.</span> What is a Hopf Fibration?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Imagine a sphere, like the surface of a ball. In three dimensions, it seems<br />
simple enough—but what if we add an extra dimension? A Hopf fibration describes<br />
a beautiful way to "fiber" higher-dimensional spaces.<br />
</p>

<p>
In mathematical terms, the Hopf fibration is a mapping: \[ S^3 \to S^2 \] where<br />
\(S^3\) is a 3-sphere, and \(S^2\) is an ordinary 2-sphere (the surface of a<br />
sphere in 3D space). The magic lies in the fact that \(S^3\) can be thought of<br />
as "made up" of circles, \(S^1\), such that each circle is mapped uniquely onto<br />
a point on \(S^2\). These circles are the fibers of the fibration.<br />
</p>
</div>
</div>

<div id="outline-container-orgee581e6" class="outline-3">
<h3 id="orgee581e6"><span class="section-number-3">1.5.</span> Why Does It Matter in Physics?</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Let's consider QM, as we know the state of a particle is represented as a vector<br />
in a Hilbert space, a high-dimensional complex vector space.  The wavefunction<br />
itself has an arbitrary phase factor (a complex number of magnitude 1). Since<br />
the phase doesn’t affect observable quantities, what really matters is the<br />
direction of the state vector, not its exact value.  This leads to the<br />
projective Hilbert space, where each point corresponds to a normalized state up<br />
to a phase factor. Mathematically, this space is somwhat of a quotient space.<br />
The Hopf fibration provides a natural way to visualize how the space of possible<br />
states is organized.  Hopf fibrations are more than just a mathematical<br />
curiosity—they are deeply connected to the structure of physical theories.<br />
</p>


<p>
If you're intrigued, dive deeper into the world of topology and see how these<br />
ideas shape our understanding of physics!<br />
</p>

<p>
The interactive Plotly graph can be accessed here: <a href="file:///Users/shrisha/Documents/orgfiles/nomad_scientist_site/snippets/other_html_files/hopf_fibration_interactive.html"> Interactive Visualisation of<br />
Hopf Fibration</a><br />
</p>



<button type="button" class="btn btn-info" data-toggle="collapse" data-target="#demo">
Source Code</button>
<div id="demo" class="collapse">
<pre><code class="python">    
import numpy as np
import pylab as plt
from matplotlib.colors import hsv_to_rgb

def hopf_inverse(phi, psi, theta):
    """Inverse map of Hopf fibration. It's a circle in 4d parameterized by theta.
    """
    return np.array([np.cos((theta + psi) / 2) * np.sin(phi / 2),
                     np.sin((theta + psi) / 2) * np.sin(phi / 2),
                     np.cos((theta - psi) / 2) * np.cos(phi / 2),
                     np.sin((theta - psi) / 2) * np.cos(phi / 2)])


def stereo_projection(v):
    """Stereographic projection of a 4d vector with pole at (0, 0, 0, 1).
    """
    v = normalize(v)
    x, y, z, w = v
    return np.array([x, y, z]) / (1 + 1e-8 - w)

def normalize(v):
    """Normalize a vector.
    """
    return np.array(v) / np.linalg.norm(v)


def norm2(v):
    """Return squared Euclidean norm of a vector.
    """
    return sum([x*x for x in v])


def get_circle(A, B, C):
    """Compute the center, radius and normal of the circle passes
       through 3 given points (A, B, C) in 3d space.
       See "https://en.wikipedia.org/wiki/Circumscribed_circle"
    """
    a = A - C
    b = B - C
    axb = np.cross(a, b)
    center = C + np.cross((norm2(a) * b - norm2(b) * a), axb) / (2 * norm2(axb))
    radius = np.sqrt(norm2(a) * norm2(b) * norm2(a - b) / (4 * norm2(axb)))
    normal = normalize(axb)
    return center, radius, normal

def transform_matrix(v):
    """Return a 3x3 orthogonal matrix that transforms y-axis (0, 1, 0) to v.
       This matrix is not uniquely determined, we simply choose one with a simple form.
    """
    y = normalize(v)
    a, b, c = y
    if a == 0:
        x = [1, 0, 0]
    else:
        x = normalize([-b, a, 0])
    z = np.cross(x, y)
    return np.array([x, y, z])

def generate_similar_colors(num_circles, base_hue=0.5, hue_variation=0.5):
    """
    Generates a list of colors for neighboring circles with similar hues.
    
    Parameters:
        num_circles (int): Number of colors to generate.
        base_hue (float): The base hue (0 to 1) for the gradient.
        hue_variation (float): The range of variation around the base hue.
    
    Returns:
        list: A list of color strings in RGB format.
    """
    hues = np.linspace(base_hue - hue_variation, base_hue + hue_variation, num_circles) % 1.0
    colors = [hsv_to_rgb([hue, 1.0, 1.0]) for hue in hues]  # Full saturation and brightness
    rgb_colors = [f"rgb({int(r*255)}, {int(g*255)}, {int(b*255)})" for r, g, b in colors]
    return rgb_colors

import numpy as np
import plotly.graph_objects as go

def plot_circle(center, radius, normal, num_points=100, color=None):
    """
    Plots a 3D circle given its center, radius, and normal vector.

    Parameters:
        center (tuple): The (x, y, z) coordinates of the circle's center.
        radius (float): The radius of the circle.
        normal (tuple): The (nx, ny, nz) normal vector of the circle.
        num_points (int): Number of points to use for plotting the circle (default: 100).
    Returns:
        trace (go.Scatter3d): A Plotly Scatter3d object representing the circle.
    """
    # Normalize the normal vector
    normal = np.array(normal)
    normal = normal / np.linalg.norm(normal)

    # Find a vector perpendicular to the normal
    if np.isclose(normal[0], 0) and np.isclose(normal[1], 0):
        tangent = np.array([1, 0, 0])  # Handle edge case when normal is along z-axis
    else:
        tangent = np.cross(normal, [0, 0, 1])
        tangent /= np.linalg.norm(tangent)
    
    # Find a second vector perpendicular to both the normal and tangent
    bitangent = np.cross(normal, tangent)
    
    # Generate points for the circle in the plane defined by normal
    theta = np.linspace(0, 2 * np.pi, num_points)
    circle_points = (
        radius * np.outer(np.cos(theta), tangent) +
        radius * np.outer(np.sin(theta), bitangent)
    )

    # Translate the circle points to the center
    circle_points += np.array(center).reshape(-1, 3)

    # Extract x, y, z coordinates
    x, y, z = circle_points[:, 0], circle_points[:, 1], circle_points[:, 2]
    
        
    if color is None:
        color = "#{:02x}{:02x}{:02x}".format(np.random.randint(0, 256),
                                             np.random.randint(0, 256),
                                             np.random.randint(0, 256))

    # Create a 3D scatter trace for Plotly
    trace = go.Scatter3d(
        x=x,
        y=y,
        z=z,
        mode='lines',
        line=dict(color= color, # 'green', 
                  width=4),
        name=f"Circle at {center}"
    )
    return trace

def plot_circles(circles, num_points=100):
    """
    Plots multiple 3D circles given a list of their parameters.

    Parameters:
        circles (list): A list of tuples, where each tuple contains:
                        (center (tuple), radius (float), normal (tuple)).
        num_points (int): Number of points to use for plotting each circle (default: 100).
    Returns:
        fig (go.Figure): A Plotly figure object containing all the circles.
    """
    # Initialize the figure
    fig = go.Figure()

    colors = "#{:02x}{:02x}{:02x}".format(
    np.ara(0, 256),
    np.random.randint(0, 256),
    np.random.randint(0, 256)
)
    
    
    # Add each circle to the figure
    for center, radius, normal in circles:
        trace = plot_circle(center, radius, normal, num_points)
        fig.add_trace(trace)

    # Customize layout
    fig.update_layout(
        title="3D Circles",
        scene=dict(
            xaxis=dict(title='X'),
            yaxis=dict(title='Y'),
            zaxis=dict(title='Z')
        ),
        showlegend=True
    )
    return fig


def plot_circles_with_colors(circles, fig=None):
    """
    Plots multiple 3D circles with unique but similar colors.
    
    Parameters:
        circles (list): A list of tuples where each tuple contains:
                        (center (tuple), radius (float), normal (tuple)).
    """
    num_circles = len(circles)
    colors = generate_similar_colors(num_circles)
    
    # Initialize the figure
    if fig is None:
        fig = go.Figure()

    # Create the 3D sphere plot
    #fig = sp.make_subplots(rows=1, cols=2, specs=[[{'type': 'scatter3d'}, {'type': 'scatter3d'}]])


    # Add each circle with its unique color
    for i, (center, radius, normal) in enumerate(circles):
        # Generate circle points
        trace = plot_circle(center, radius, normal)
        trace.line.color = colors[i]  # Assign the generated color
        fig.add_trace(trace, row=1, col=2)

    # Customize layout
    fig.update_layout(
        title="Hopf Fibration",
        scene=dict(
            xaxis=dict(title='X'),
            yaxis=dict(title='Y'),
            zaxis=dict(title='Z')
        ),
        showlegend=False
    )
    #fig.show()
        
    
    fig.write_html("hopf_fibration_interactive.html")
    
    
    
# Function to calculate points on a sphere based on phi & psi
def spherical_points(phi, psi):
    # Convert spherical coordinates (phi, psi) to Cartesian coordinates
    x = np.sin(phi) * np.cos(psi)
    y = np.sin(phi) * np.sin(psi)
    z = np.cos(phi)
    return x, y, z


def plot_points_on_sphere(fig, phi_list, psi_list):
    # Plot points on a sphere
    x_sphere, y_sphere, z_sphere = [], [], []
    for phi, psi in zip(phi_list, psi_list):
        x, y, z = spherical_points(phi, psi)
        x_sphere.append(x)
        y_sphere.append(y)
        z_sphere.append(z)
        
        
    # Generate the spherical grid of points
    phi_grid = np.linspace(0, np.pi, 100)  # More points for the grid
    psi_grid = np.linspace(0, 2 * np.pi, 100)
    phi_grid, psi_grid = np.meshgrid(phi_grid, psi_grid)

    # Convert the grid points to Cartesian coordinates
    x_grid = np.sin(phi_grid) * np.cos(psi_grid)
    y_grid = np.sin(phi_grid) * np.sin(psi_grid)
    z_grid = np.cos(phi_grid)

    fig.add_trace(
        go.Scatter3d(
            x=x_sphere, y=y_sphere, z=z_sphere,
            mode='markers',
            marker=dict(size=4, color=colors),
            name="Points on S2"
        ), row=1, col=1
    ) 
    


if __name__ == "__main__":
    N = 200
    phi_range = np.linspace(1e-3, np.pi, N)  # From south pole to north pole
    psi_range = (0, 5 * np.pi)
    
#     phi_range = np.linspace(np.pi/8, np.pi, N)  # From south pole (0) to north pole (pi)
#     psi_range = np.linspace(0, 4 * np.pi, N)  # Full rotation (0 to 2pi)

    phi_list = np.linspace(phi_range[0], phi_range[-1], N)
    psi_list = np.linspace(psi_range[0], psi_range[1], N)
   


#     phi_list = np.random.random(N) * (phi_range[1] - phi_range[0]) + phi_range[0]
#     psi_list = np.random.random(N) * (psi_range[1] - psi_range[0]) + psi_range[0]

    
    #
    colors = generate_similar_colors(N)

    # Create the 3D sphere plot
    fig = sp.make_subplots(rows=1, cols=2, specs=[[{'type': 'scatter3d'}, {'type': 'scatter3d'}]])

    #
    plot_points_on_sphere(fig, phi_list, psi_list)
    
    #
    circles = []
    for phi, psi in zip(phi_list, psi_list):
        color = np.random.random(3)
        A, B, C = [stereo_projection(hopf_inverse(phi, psi, theta)) for theta in (0, np.pi/2, np.pi)]
        circles.append(get_circle(A, B, C))
    plot_circles_with_colors(circles, fig)
</code></pre> 
</div>


<div class="myimgcontainer">
<p>
<img src="imgs/fig1.png" alt="fig1.png" /><br />
<img src="imgs/fig2.png" alt="fig2.png" /><br />
<img src="imgs/fig4.png" alt="fig4.png" /><br />
<img src="imgs/fig6.png" alt="fig6.png" /><br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-12-02 Mon 00:00</p>
<p class="author">Author: Shrisha Rao</p>
<p class="date">Created: 2024-12-04 Wed 13:03</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
