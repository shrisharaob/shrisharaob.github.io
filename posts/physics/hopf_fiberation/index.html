<!DOCTYPE html>
<html lang="en">
<head>
<!-- 04 Dec. 2024 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hopf Fibrations</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Shrisha Rao">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1687066-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-1687066-2');
</script>
<link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css' rel='stylesheet' integrity='sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==' crossorigin='anonymous'/>
<meta description='The blog of Shrisha Rao'/>
<link rel='alternate' type='application+rss/xml' title='The blog of Shrisha Rao' href='posts/rss.xml'/>
<link rel="stylesheet" href="../../../css/site.css?v=b5b7fa25d3b5180d3a91f21724efbeef14457af6f2d28a5d32e82233efe9f356" type="text/css">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<header id="preamble" class="status">
<div class="logo">
  <a href="/">
    <img src="/images/ai_art.jpeg" class="avatar" alt="My photo"/>
  </a>
  <div class="title-section">
    <a href="/"><h1>The noMad Scientist</h1></a>
    <sub style="line-height:1;"> <h2>Poetic Particles colliding in Lyrical Labirynths</h2> </sub>
    <div style="padding-top: 20px; padding-bottom: 20px;">
      <nav>
	<ul>
          <li><a href="/posts/ai_ml/list_of_ml_posts/index.html"> AI/ML </a></li>
          <li><a href="/posts/philosophy/philosophy.html"> Philosophy </a></li>
	  <li><a href="/posts/physics/physics.html"> Physics </a></li>
	  <li><a href="/posts/poetry/poetry.html"> Poetry </a></li>
          <li><a href="/posts/tutorials_list/list_of_tutorials/index.html"> Tutorials </a></li>
          <li><a href="/posts/archive.html"> Posts </a></li>
          <li><a href="/about.html"> About </a></li>
          <!-- add more as needed -->
	</ul>
      </nav>
    </div>
  </div>
  <div id="social">
    <a title="shrisharaob on Github" href="https://github.com/shrisharaob">
      <i class="fa-brands fa-github"></i>
    </a>
    <a title="shrisharao on LinkedIn" href="https://linkedin.com/in/shrisha-rao">
      <i class="fa-brands fa-linkedin"></i>
    </a>
    <!-- <a title="dmacvicar on Twitter" href="https://twitter.com/dmacvicar"> -->
      <!--   <i class="fa-brands fa-twitter"></i> -->
      <!-- </a> -->
    <!-- <a title="RSS feed" id="atom" href="posts/rss.xml"> -->
    <!--   <i class="fa-solid fa-rss"></i> -->
    <!-- </a> -->
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script>
  function addDarkmodeWidget() {
    new Darkmode({
      bottom: 'unset', // Remove bottom positioning
      right: '10px', // Remove default right positioning
      left: 'unset', // Remove default left positioning
      label: 'ðŸŒ“', // Custom label/icon
      time: '0.5s', // Transition time
      autoMatchOsTheme: false, // Disable automatic theme matching based on OS preferences
      // location: 'top-right' // Set position to top right
    }).showWidget();
  }
  window.addEventListener('load', addDarkmodeWidget);
</script>
</header>
<main id="content">
<header>
<h1 class="title">Hopf Fibrations</h1>
<p class="subtitle">Dec 02, 2024</p>
</header><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
<link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


<section id="outline-container-orgcc4de8a" class="outline-2">
<h2 id="orgcc4de8a">Exploring Hopf Fibrations</h2>
<div class="outline-text-2" id="text-orgcc4de8a">
<p>
The Hopf fibration is an interesting concept providing insights into geometry,<br>
topology, and QM. We will explore what Hopf fibrations are and their<br>
significance in physics.<br>
</p>

<p>
In geometry, the concepts of <code>base space</code>, <code>fibers</code>, and <code>total space</code> are<br>
fundamental for understanding structures like fiber bundles and fibrations.<br>
</p>
</div>

<div id="outline-container-org1ab38db" class="outline-3">
<h3 id="org1ab38db">Base Space</h3>
<div class="outline-text-3" id="text-org1ab38db">
<p>
The <code>base space</code> is the &ldquo;foundation&rdquo; over which everything is organized. It is<br>
typically a lower-dimensional space that provides the framework for the<br>
structure of the fiber bundle.<br>
</p>

<ul class="org-ul">
<li><b>Example</b>: In case of a cylinder, the base space is the disc.<br>
\( D=\{(x, y)\in {\mathbb R^2}: (x-a)^2+(y-b)^2 \le R^2\} \)<br></li>
</ul>
</div>
</div>

<div id="outline-container-org3fa8448" class="outline-3">
<h3 id="org3fa8448">Fibers</h3>
<div class="outline-text-3" id="text-org3fa8448">
<p>
Fibers are the individual &ldquo;threads&rdquo; or spaces that are attached to each point of<br>
the base space. They are often all the same type of space, forming a consistent<br>
&ldquo;shape&rdquo; across the entire structure.<br>
</p>

<ul class="org-ul">
<li><b>Example</b>: In case of a cylinder, the fibers are circles, straight lines, attached to each point on the disc.<br></li>
</ul>
</div>
</div>

<div id="outline-container-org7918559" class="outline-3">
<h3 id="org7918559">Total Space</h3>
<div class="outline-text-3" id="text-org7918559">
<p>
The <code>total space</code> is the &ldquo;combined&rdquo; space that includes both the base space and<br>
all the fibers. It can be thought of as the entire structure before projecting<br>
down to just the base space.<br>
</p>

<ul class="org-ul">
<li><b>Example</b>: In case of a cylinder, the total space is the cylinder in \( \mathbb
  {R}^3 \)<br></li>
</ul>
</div>
</div>


<div id="outline-container-org04f091e" class="outline-3">
<h3 id="org04f091e">What is a Hopf Fibration?</h3>
<div class="outline-text-3" id="text-org04f091e">
<p>
Imagine a sphere, like the surface of a ball. In three dimensions, it seems<br>
simple enoughâ€”but what if we add an extra dimension? A Hopf fibration describes<br>
a beautiful way to &ldquo;fiber&rdquo; higher-dimensional spaces.<br>
</p>

<p>
In mathematical terms, the Hopf fibration is a mapping: \[ S^3 \to S^2 \] where<br>
\(S^3\) is a 3-sphere, and \(S^2\) is an ordinary 2-sphere (the surface of a<br>
sphere in 3D space). The magic lies in the fact that \(S^3\) can be thought of<br>
as &ldquo;made up&rdquo; of circles, \(S^1\), such that each circle is mapped uniquely onto<br>
a point on \(S^2\). These circles are the fibers of the fibration.<br>
</p>
</div>
</div>

<div id="outline-container-orgeb541d2" class="outline-3">
<h3 id="orgeb541d2">Why Does It Matter in Physics?</h3>
<div class="outline-text-3" id="text-orgeb541d2">
<p>
Let&rsquo;s consider QM, as we know the state of a particle is represented as a vector<br>
in a Hilbert space, a high-dimensional complex vector space.  The wavefunction<br>
itself has an arbitrary phase factor (a complex number of magnitude 1). Since<br>
the phase doesnâ€™t affect observable quantities, what really matters is the<br>
direction of the state vector, not its exact value.  This leads to the<br>
projective Hilbert space, where each point corresponds to a normalized state up<br>
to a phase factor. Mathematically, this space is somwhat of a quotient space.<br>
The Hopf fibration provides a natural way to visualize how the space of possible<br>
states is organized.  Hopf fibrations are more than just a mathematical<br>
curiosityâ€”they are deeply connected to the structure of physical theories.<br>
</p>


<p>
If you&rsquo;re intrigued, dive deeper into the world of topology and see how these<br>
ideas shape our understanding of physics!<br>
</p>

<p>
The interactive Plotly graph can be accessed here: <a href="file:///github/home/Documents/orgfiles/nomad_scientist_site/snippets/other_html_files/hopf_fibration_interactive.html"> Interactive Visualisation of<br>
Hopf Fibration</a><br>
</p>


<p>
<img src="imgs/fig1.png" alt="fig1.png"><br>
<img src="imgs/fig2.png" alt="fig2.png"><br>
<img src="imgs/fig4.png" alt="fig4.png"><br>
<img src="imgs/fig6.png" alt="fig6.png"><br>
</p>




<button type="button" class="btn btn-info" data-toggle="collapse" data-target="#demo">
Source Code</button>
<div id="demo" class="collapse">
<pre><code class="python">    
import numpy as np
import pylab as plt
from matplotlib.colors import hsv_to_rgb

def hopf_inverse(phi, psi, theta):
    """Inverse map of Hopf fibration. It's a circle in 4d parameterized by theta.
    """
    return np.array([np.cos((theta + psi) / 2) * np.sin(phi / 2),
                     np.sin((theta + psi) / 2) * np.sin(phi / 2),
                     np.cos((theta - psi) / 2) * np.cos(phi / 2),
                     np.sin((theta - psi) / 2) * np.cos(phi / 2)])


def stereo_projection(v):
    """Stereographic projection of a 4d vector with pole at (0, 0, 0, 1).
    """
    v = normalize(v)
    x, y, z, w = v
    return np.array([x, y, z]) / (1 + 1e-8 - w)

def normalize(v):
    """Normalize a vector.
    """
    return np.array(v) / np.linalg.norm(v)


def norm2(v):
    """Return squared Euclidean norm of a vector.
    """
    return sum([x*x for x in v])


def get_circle(A, B, C):
    """Compute the center, radius and normal of the circle passes
       through 3 given points (A, B, C) in 3d space.
       See "https://en.wikipedia.org/wiki/Circumscribed_circle"
    """
    a = A - C
    b = B - C
    axb = np.cross(a, b)
    center = C + np.cross((norm2(a) * b - norm2(b) * a), axb) / (2 * norm2(axb))
    radius = np.sqrt(norm2(a) * norm2(b) * norm2(a - b) / (4 * norm2(axb)))
    normal = normalize(axb)
    return center, radius, normal

def transform_matrix(v):
    """Return a 3x3 orthogonal matrix that transforms y-axis (0, 1, 0) to v.
       This matrix is not uniquely determined, we simply choose one with a simple form.
    """
    y = normalize(v)
    a, b, c = y
    if a == 0:
        x = [1, 0, 0]
    else:
        x = normalize([-b, a, 0])
    z = np.cross(x, y)
    return np.array([x, y, z])

def generate_similar_colors(num_circles, base_hue=0.5, hue_variation=0.5):
    """
    Generates a list of colors for neighboring circles with similar hues.
    
    Parameters:
        num_circles (int): Number of colors to generate.
        base_hue (float): The base hue (0 to 1) for the gradient.
        hue_variation (float): The range of variation around the base hue.
    
    Returns:
        list: A list of color strings in RGB format.
    """
    hues = np.linspace(base_hue - hue_variation, base_hue + hue_variation, num_circles) % 1.0
    colors = [hsv_to_rgb([hue, 1.0, 1.0]) for hue in hues]  # Full saturation and brightness
    rgb_colors = [f"rgb({int(r*255)}, {int(g*255)}, {int(b*255)})" for r, g, b in colors]
    return rgb_colors

import numpy as np
import plotly.graph_objects as go

def plot_circle(center, radius, normal, num_points=100, color=None):
    """
    Plots a 3D circle given its center, radius, and normal vector.

    Parameters:
        center (tuple): The (x, y, z) coordinates of the circle's center.
        radius (float): The radius of the circle.
        normal (tuple): The (nx, ny, nz) normal vector of the circle.
        num_points (int): Number of points to use for plotting the circle (default: 100).
    Returns:
        trace (go.Scatter3d): A Plotly Scatter3d object representing the circle.
    """
    # Normalize the normal vector
    normal = np.array(normal)
    normal = normal / np.linalg.norm(normal)

    # Find a vector perpendicular to the normal
    if np.isclose(normal[0], 0) and np.isclose(normal[1], 0):
        tangent = np.array([1, 0, 0])  # Handle edge case when normal is along z-axis
    else:
        tangent = np.cross(normal, [0, 0, 1])
        tangent /= np.linalg.norm(tangent)
    
    # Find a second vector perpendicular to both the normal and tangent
    bitangent = np.cross(normal, tangent)
    
    # Generate points for the circle in the plane defined by normal
    theta = np.linspace(0, 2 * np.pi, num_points)
    circle_points = (
        radius * np.outer(np.cos(theta), tangent) +
        radius * np.outer(np.sin(theta), bitangent)
    )

    # Translate the circle points to the center
    circle_points += np.array(center).reshape(-1, 3)

    # Extract x, y, z coordinates
    x, y, z = circle_points[:, 0], circle_points[:, 1], circle_points[:, 2]
    
        
    if color is None:
        color = "#{:02x}{:02x}{:02x}".format(np.random.randint(0, 256),
                                             np.random.randint(0, 256),
                                             np.random.randint(0, 256))

    # Create a 3D scatter trace for Plotly
    trace = go.Scatter3d(
        x=x,
        y=y,
        z=z,
        mode='lines',
        line=dict(color= color, # 'green', 
                  width=4),
        name=f"Circle at {center}"
    )
    return trace

def plot_circles(circles, num_points=100):
    """
    Plots multiple 3D circles given a list of their parameters.

    Parameters:
        circles (list): A list of tuples, where each tuple contains:
                        (center (tuple), radius (float), normal (tuple)).
        num_points (int): Number of points to use for plotting each circle (default: 100).
    Returns:
        fig (go.Figure): A Plotly figure object containing all the circles.
    """
    # Initialize the figure
    fig = go.Figure()

    colors = "#{:02x}{:02x}{:02x}".format(
    np.ara(0, 256),
    np.random.randint(0, 256),
    np.random.randint(0, 256)
)
    
    
    # Add each circle to the figure
    for center, radius, normal in circles:
        trace = plot_circle(center, radius, normal, num_points)
        fig.add_trace(trace)

    # Customize layout
    fig.update_layout(
        title="3D Circles",
        scene=dict(
            xaxis=dict(title='X'),
            yaxis=dict(title='Y'),
            zaxis=dict(title='Z')
        ),
        showlegend=True
    )
    return fig


def plot_circles_with_colors(circles, fig=None):
    """
    Plots multiple 3D circles with unique but similar colors.
    
    Parameters:
        circles (list): A list of tuples where each tuple contains:
                        (center (tuple), radius (float), normal (tuple)).
    """
    num_circles = len(circles)
    colors = generate_similar_colors(num_circles)
    
    # Initialize the figure
    if fig is None:
        fig = go.Figure()

    # Create the 3D sphere plot
    #fig = sp.make_subplots(rows=1, cols=2, specs=[[{'type': 'scatter3d'}, {'type': 'scatter3d'}]])


    # Add each circle with its unique color
    for i, (center, radius, normal) in enumerate(circles):
        # Generate circle points
        trace = plot_circle(center, radius, normal)
        trace.line.color = colors[i]  # Assign the generated color
        fig.add_trace(trace, row=1, col=2)

    # Customize layout
    fig.update_layout(
        title="Hopf Fibration",
        scene=dict(
            xaxis=dict(title='X'),
            yaxis=dict(title='Y'),
            zaxis=dict(title='Z')
        ),
        showlegend=False
    )
    #fig.show()
        
    
    fig.write_html("hopf_fibration_interactive.html")
    
    
    
# Function to calculate points on a sphere based on phi & psi
def spherical_points(phi, psi):
    # Convert spherical coordinates (phi, psi) to Cartesian coordinates
    x = np.sin(phi) * np.cos(psi)
    y = np.sin(phi) * np.sin(psi)
    z = np.cos(phi)
    return x, y, z


def plot_points_on_sphere(fig, phi_list, psi_list):
    # Plot points on a sphere
    x_sphere, y_sphere, z_sphere = [], [], []
    for phi, psi in zip(phi_list, psi_list):
        x, y, z = spherical_points(phi, psi)
        x_sphere.append(x)
        y_sphere.append(y)
        z_sphere.append(z)
        
        
    # Generate the spherical grid of points
    phi_grid = np.linspace(0, np.pi, 100)  # More points for the grid
    psi_grid = np.linspace(0, 2 * np.pi, 100)
    phi_grid, psi_grid = np.meshgrid(phi_grid, psi_grid)

    # Convert the grid points to Cartesian coordinates
    x_grid = np.sin(phi_grid) * np.cos(psi_grid)
    y_grid = np.sin(phi_grid) * np.sin(psi_grid)
    z_grid = np.cos(phi_grid)

    fig.add_trace(
        go.Scatter3d(
            x=x_sphere, y=y_sphere, z=z_sphere,
            mode='markers',
            marker=dict(size=4, color=colors),
            name="Points on S2"
        ), row=1, col=1
    ) 
    


if __name__ == "__main__":
    N = 200
    phi_range = np.linspace(1e-3, np.pi, N)  # From south pole to north pole
    psi_range = (0, 5 * np.pi)
    
#     phi_range = np.linspace(np.pi/8, np.pi, N)  # From south pole (0) to north pole (pi)
#     psi_range = np.linspace(0, 4 * np.pi, N)  # Full rotation (0 to 2pi)

    phi_list = np.linspace(phi_range[0], phi_range[-1], N)
    psi_list = np.linspace(psi_range[0], psi_range[1], N)
   


#     phi_list = np.random.random(N) * (phi_range[1] - phi_range[0]) + phi_range[0]
#     psi_list = np.random.random(N) * (psi_range[1] - psi_range[0]) + psi_range[0]

    
    #
    colors = generate_similar_colors(N)

    # Create the 3D sphere plot
    fig = sp.make_subplots(rows=1, cols=2, specs=[[{'type': 'scatter3d'}, {'type': 'scatter3d'}]])

    #
    plot_points_on_sphere(fig, phi_list, psi_list)
    
    #
    circles = []
    for phi, psi in zip(phi_list, psi_list):
        color = np.random.random(3)
        A, B, C = [stereo_projection(hopf_inverse(phi, psi, theta)) for theta in (0, np.pi/2, np.pi)]
        circles.append(get_circle(A, B, C))
    plot_circles_with_colors(circles, fig)
</code></pre> 
</div>
</div>
</div>
</section>
</main>
<footer id="postamble" class="status">
<p>Last updated 04 Dec. 2024. Built with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.4). <a href="/README.html">Details</a>.</p>
</footer>
</body>
</html>
